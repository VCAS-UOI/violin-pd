# Violin VLC xmit firmware

The firmware code for the VLC xmit board is kept in this directory.

## Credits

The VIOLIN project has been co-financed by the European Union and Greek national
funds through the Operational Program Competitiveness, Entrepreneurship and
Innovation, under the call RESEARCH-CREATE-INNOVATE (project code: T1EDK-02419).

The firmware depends on the STM32 HAL library (see license files under `Drivers`), FreeRTOS (see license in `Middlewares/Third_Party/FreeRTOS/Source`), and the lwIP library (see license at the top of `Middlewares/Third_Party/LwIP` source files).

## Code generation

This project was tested with STM32CubeMX 6.12.0, STM32Cube FW_H7 V1.11.2, [STM32 VS Code Extension v2.1.0](https://marketplace.visualstudio.com/items?itemName=stmicroelectronics.stm32-vscode-extension), STM32CubeCLT v1.16.

Generate initialization code by running STM32cubeMX on `vlcXmit.ioc`.


The following files are modified/added from the generated code:
```
Inc/main.h
Inc/printf.h
Src/main.c
Src/printf.c
Src/modulate.c
Src/FreeRTOS-openocd.c
Src/vlcTasks.c
```
Nearly all changes in generated files are inside the `USER CODE` comment code sections so they should be preserved when cubeMX (re-)generates code. In `main.c`, you need to modify the newFiltQueue initialization to:
```
newFlitQHandle = osMessageQueueNew (2, sizeof(FlitInfo_t), &newFlitQ_attributes);
```
There is a (preserved) comment just below the queue initialization as a reminder.

A modified linker script is required.
Modify [`cmake/gcc-arm-none-eabi.cmake`](./cmake/gcc-arm-none-eabi.cmake#L42) to change the linker script to `STM32H743ZITx_ETH_FLASH.ld`.

In [`CMakeLists.txt`](./CMakeLists.txt#L51) add the above source (not the include) files.
The path should start with `../../`.

Note that the Independent Windowed Watchdog is configured in the .ioc file but the `MX_IWDG1_Init()` function is never called.
We call an equivalent code in an RTOS task after the first VLC transmission is started.

## Nucleo board connections

### Power supply

In the original VIOLIN transmitter, the microcontroller board is powered by a [Power over Ethernet (PoE) powered device (PD) board](https://www.analog.com/en/resources/evaluation-hardware-and-software/evaluation-boards-kits/dc2583a.html), via a DC-DC converter.
The PoE PD board also supplies the LED and its driver.
In this case the power selection jumper of the nucleo board must be set correctly.

For direct board to board testing, without a VLC link between them, or when the LED is supplied separately, the nucleo board can be supplied via the ST-link USB connector.

### Data output

The main data output is on pin PE9 (`TIM1_CH1`)

### Ethernet connection

In the original VIOLIN transmitter the ethernet connector of the nucleo board is connected to the PoE PD ethernet output.
 If PoE is not used, you can connect it to a common network switch.

The firmware uses DHCP to obtain an IP (v4 only) address.
The IP address of a PC which provides the data to transmit over VLC is [compiled into the firmware](./Inc/main.h#L100),  `#define myIP4_ADDR`.
You should modify it according to your system.

## Brief firmware description

The firmware uses FreeRTOS and LwIP which are bundled with the [STM32Cube FW_H7 library](https://github.com/STMicroelectronics/STM32CubeH7).

The [Manchester-coded](https://en.wikipedia.org/wiki/Manchester_code), output signal is generated by a timer peripheral using its PWM capabilities. 
The transmitted data are prepared by the core and stored into SRAM.
DMA is used for delivering the data to the timer following the method described in chapter 5 of [AN4776 General-purpose timer cookbook for STM32 microcontrollers](https://www.st.com/resource/en/application_note/an4776-generalpurpose-timer-cookbook-for-stm32-microcontrollers-stmicroelectronics.pdf).

Once a VLC transmission starts, the next flit is requested by the server.
As VLC transmission is relatively slow, this allows enough time for the next flit to be received over ethernet, the data to be line-coded and converted to the format expected by the timer.
Double buffering is used so that while one flit is transmitted over the VLC link, the next is being prepared in a separate memory buffer.

Two concurent FreeRTOS tasks are running.
The [`StartDefaultTask`](./Src/vlcTasks.c#L135) is responsible for handling the communication with the server via Ethernet and the processing of the transmission data: line encoding and conversion into a suitable form for the timer peripheral.
It also handles the initiation of the timer for the very first time.

The other FreeRTOS task, [`vlcXmit`](./Src/vlcTasks.c#L39), waits for a task notification from the interrupt handler which is called when the DMA transfer to the timer completes.
It then checks if the current or a new VLC frame will be transmitted.
(The first byte of the ethernet-received flit is the number of times it is to be transmitted over the VLC link. This byte is not transmitted over the VLC link.)
In the latter case, the task re-starts the DMA transfer from the other buffer and enables the `StartDefaultTask` to request the next frame from the server.

The two tasks communicate via a message queue (`newFlitQ`), which provides `vlcXmit` with the required information of each new flit after it has been processed, and a semaphore `getNextFlit`, which enables the `StartDefaultTask` to request the next frame from the server.

If the next flit is not ready by the time the DMA signals the completion of the current transfer, the existing flit is re-transmitted.
If we did not transmit anything, the LED would have been either turned off or it would have been fully on. This would be perceived as a difference in brightness, or flickering, which is not acceptable.
To keep the brightness unchanged we could be sending dummy data.
Instead, we decided to send again the current data as this might be more useful: the receiver will have another chance to get any missing/corrupted data.

When sending very small files, something the lwIP/STM HAL code freezes in some corner cases.
To keep the whole system from breaking, we use a watchdog which resets the board if nothing is received though the ethernet for some seconds.

### Memory use

Most of the variables, task stack space, etc are in DTCM RAM as it is the fastest SRAM in the system.

However, Timer 1 is in D2 and the DMA controller cannot access DTCM.
Therefore we place both buffers (64KB each) in `RAM_D2`.
We could have used `RAM_D1` (AXI SRAM) but it should be faster to keep the access in D2.
The [linker script](./STM32H743ZITx_ETH_FLASH.ld#L180) defines section names for this purpose (`WavesSection0`/`1`) and they are used in the declaration of the buffers.
The MPU is configured so that these areas are not cached to avoid coherency problems.

Similarly the ETH peripheral has its own DMA controller which cannot access DTCM.
The ETH DMA controller is used to fetch 'packet descriptors' and access 'memory pools' for packet data. We place them also on RAM_D2, but in a different bank (SRAM3 - 32KB) from the timer data to allow concurrent access. The linker script defines a `.lwip_sec` section with specific places for the Rx, Tx descriptors and the memory pools.
